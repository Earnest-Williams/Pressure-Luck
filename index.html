<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Push‑Your‑Luck — Faces & Dice (Plain JS)</title>
  <style>
    :root{
      --bg1:#0f172a;/* slate-900 */
      --bg2:#0b1220;/* slate-950 */
      --text:#e2e8f0;/* slate-100 */
      --muted:#cbd5e1;/* slate-300 */
      --muted2:rgba(255,255,255,.7);
      --border:rgba(255,255,255,.1);
      --highlight:#34d399;/* emerald-400 */
      --accent:#10b981;/* emerald-500 */
      --accent2:#f59e0b;/* amber-500 */
      --danger:#f43f5e;/* rose-500 */
      --shadow:0 10px 15px -3px rgba(0,0,0,.2),0 4px 6px -4px rgba(0,0,0,.2);
    }
    html,body{height:100%;}
    body{margin:0;color:var(--text);background:linear-gradient(to bottom,var(--bg1),var(--bg2));font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";}
    .container{max-width:1100px;margin:0 auto;padding:24px;}
    h1{font-size:22px;margin:0;font-weight:600;letter-spacing:.2px}
    .row{display:flex;gap:12px;flex-wrap:wrap;}
    .grid-3{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:16px}
    @media (max-width:900px){.grid-3{grid-template-columns:1fr}}
    .grid-2{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:16px}
    @media (max-width:900px){.grid-2{grid-template-columns:1fr}}
    .card{border:1px solid var(--border);background:rgba(255,255,255,.05);border-radius:16px;padding:16px;box-shadow:var(--shadow)}
    .card .title{color:var(--muted2);text-transform:uppercase;letter-spacing:.08em;font-size:12px;margin-bottom:8px}
    .btn{border:1px solid var(--border);border-radius:14px;padding:10px 14px;background:transparent;color:var(--text);cursor:pointer}
    .btn:hover{background:rgba(255,255,255,.06)}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn-primary{background:var(--accent);border-color:var(--accent);color:#0f172a;font-weight:600}
    .btn-primary:hover{filter:brightness(1.05)}
    .btn-warn{border-color:var(--danger);color:#ffe4e6}
    .kbd{border:1px solid var(--border);border-radius:6px;padding:2px 6px}
    .pill{display:inline-block;border:1px solid var(--border);border-radius:10px;padding:2px 8px;font-size:12px}
    .muted{color:var(--muted2)}
    .dice-list{display:flex;flex-wrap:wrap;gap:12px}
    .die-tile{display:flex;align-items:center;gap:12px;border:1px solid var(--border);border-radius:12px;padding:10px 12px 10px 10px}
    .die-tile.selected{border-color:var(--highlight);background:rgba(16,185,129,.12)}
    .destroy{display:inline-block;border:1px solid var(--border);border-radius:10px;padding:2px 8px;font-size:12px}
    .destroy.active{border-color:#fecdd3;background:rgba(244,63,94,.2);color:#fee2e2}
    .destroy.disabled{opacity:.4;pointer-events:none}
    svg{display:block}
    .log{list-style:none;margin:0;padding:0}
    .log li{font-size:14px;color:var(--muted2);margin:4px 0}
    input[type=number]{width:110px;border:1px solid var(--border);border-radius:8px;background:rgba(0,0,0,.35);color:var(--text);padding:6px}
    #abTarget.pending{border-style:dashed;color:var(--muted2);background:rgba(255,255,255,.04)}
  </style>
</head>
<body>
  <div class="container">
    <header class="row" style="justify-content:space-between;align-items:center;margin-bottom:16px">
      <h1>Push‑Your‑Luck — Per‑Die Upgrades + Automation</h1>
      <button id="btnReset" class="btn">Reset</button>
    </header>

    <section class="grid-3" style="margin-bottom:16px">
      <div class="card">
        <div class="title">Bank</div>
        <div id="bank" style="font-size:32px;font-weight:700">0</div>
        <div class="muted" style="font-size:12px;margin-top:6px">Interest <span id="interestRate">+0.0</span>%/tick • Price scale ×<span id="priceScale">1.00</span></div>
      </div>
      <div class="card">
        <div class="title">Pot (at risk)</div>
        <div id="pot" style="font-size:32px;font-weight:700">0</div>
        <div class="muted" style="font-size:12px;margin-top:6px">Heat ×<span id="heatRaw">1.00</span> • Payout ×<span id="heatPay">1</span> • Streak <span id="streak">0</span> • Overheat <span id="overheatRisk">0.0</span>%<span id="overheatStage" class="pill" style="margin-left:6px;display:none"></span><span id="overheatNext" class="muted" style="margin-left:6px;display:none">next ×<span id="overheatNextValue">0.0</span></span><span id="hazardBadge" class="pill" style="margin-left:6px;display:none"></span></div>
      </div>
      <div class="card">
        <div class="title">Current Setup</div>
        <div style="font-size:14px">
          <div style="margin-bottom:6px">Dice: <span id="diceCount" style="font-weight:600">1</span></div>
          <div class="grid-2" style="row-gap:6px">
            <div>Selected die</div><div style="text-align:right;font-weight:600" id="selectedStats">#1 — d2, 1 winning</div>
            <div>Base heat</div><div style="text-align:right;font-weight:600">×<span id="baseHeat">1.00</span></div>
            <div>Base per‑win</div><div style="text-align:right;font-weight:600">×<span id="perWin">1.00</span></div>
            <div>Bust chance (roll)</div><div style="text-align:right;font-weight:600"><span id="bustPct">0.00</span>%</div>
            <div>Expected successes</div><div style="text-align:right;font-weight:600"><span id="expSucc">0.00</span></div>
          </div>
          <div class="muted" style="font-size:12px;margin-top:8px">Press <span class="kbd">R</span> to Roll, <span class="kbd">B</span> to Bank</div>
        </div>
      </div>
    </section>

    <section class="row" style="margin-bottom:16px">
      <button id="btnRoll" class="btn btn-primary">Roll</button>
      <button id="btnBank" class="btn" style="background:var(--accent2);border-color:var(--accent2);color:#0f172a;font-weight:600">Bank</button>
    </section>

    <section class="card" style="margin-bottom:16px">
      <div class="title">Dice & Last Roll (click a die to select)</div>
      <div id="diceList" class="dice-list"></div>
    </section>

    <section class="grid-3" style="margin-bottom:16px">
      <div class="card">
        <div class="title">Add a Die</div>
        <div class="muted" style="font-size:14px;margin-bottom:8px">New die starts as d2 with 1 winning face.</div>
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div>
            <div style="font-size:20px;font-weight:600"><span id="diceCountNow">1</span> → <span id="diceCountNext">2</span></div>
            <div class="muted" style="font-size:14px">Cost: <span id="costDie">25</span></div>
          </div>
          <button id="btnBuyDie" class="btn">Buy</button>
        </div>
      </div>

      <div class="card">
        <div class="title">Add a Side (selected die)</div>
        <div class="muted" style="font-size:14px;margin-bottom:8px">Increase sides on the selected die.</div>
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div>
            <div style="font-size:20px;font-weight:600">d<span id="selSides">2</span> → d<span id="selSidesNext">3</span></div>
            <div class="muted" style="font-size:14px">Cost: <span id="costSide">15</span></div>
          </div>
          <button id="btnBuySide" class="btn">Buy</button>
        </div>
      </div>

      <div class="card">
        <div class="title">Add a Winning Face (selected die)</div>
        <div class="muted" style="font-size:14px;margin-bottom:8px">Max is N−1 for that die.</div>
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div>
            <div style="font-size:20px;font-weight:600"><span id="selWin">1</span>/<span id="selSides2">2</span> → <span id="selWinNext">1</span>/<span id="selSides3">2</span></div>
            <div class="muted" style="font-size:14px">Cost: <span id="costWin">18</span></div>
          </div>
          <button id="btnBuyWin" class="btn">Buy</button>
        </div>
      </div>
    </section>

    <section class="grid-2" style="margin-bottom:16px">
      <div class="card">
        <div class="title">Auto Roller</div>
        <div class="muted" style="font-size:14px;margin-bottom:10px">Automatically rolls at intervals. Upgrade to reduce the interval. Speed scales indefinitely.</div>
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
          <div>
            <div style="font-size:14px">Owned: <span id="arOwned" style="font-weight:600">No</span></div>
            <div style="font-size:14px">Level: <span id="arLevel" style="font-weight:600">0</span></div>
            <div style="font-size:14px">Interval: <span id="arInterval" style="font-weight:600">—</span></div>
          </div>
          <div class="row">
            <button id="btnBuyAR" class="btn">Buy/Upgrade (<span id="costAR">80</span>)</button>
            <button id="btnToggleAR" class="btn">Start</button>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="title">Auto Banker</div>
        <div class="muted" style="font-size:14px;margin-bottom:10px">Automatically banks when the pot reaches the target value. Price is fixed; affected by price reductions.</div>
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
          <div>
            <div style="font-size:14px">Owned: <span id="abOwned" style="font-weight:600">No</span></div>
            <div style="font-size:14px">Target: <input id="abTarget" type="number" min="1" step="1" value="20"></div>
            <div id="abPendingHint" class="muted" style="font-size:12px;margin-top:4px;display:none">Effective after purchase</div>
          </div>
          <div class="row">
            <button id="btnBuyAB" class="btn">Buy (<span id="costAB">90</span>)</button>
            <button id="btnToggleAB" class="btn">Enable</button>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="title">Log</div>
      <ul id="log" class="log"></ul>
    </section>

    <p class="muted" style="font-size:12px;margin-top:12px">
      Rules: If at least one die shows a winning face, you add to the pot and may roll again or bank; if none win, you bust and lose the pot.
        Add a Die starts at 25 and scales ×1.55 for each die already owned; any non‑die purchase increases future Add‑a‑Die price by +18% (multiplicative).
      Starting heat adds +0.1 per side above 2 on each die; streak adds +0.05 per success. Only whole‑number heat levels (×2, ×3, …) multiply payout.
      Crossing ×2.5, ×3.5, ×4.5 heat (and beyond) adds escalating forced cooldown chances that automatically bust the pot at +5%, +8%, +12% per tier.
      Base per‑win payout increases by +0.1 for each additional die. Destroying a die halves all current buy prices and adds +0.1%/tick interest per side of the destroyed die.
    </p>
  </div>

  <script>
    // ===== Helpers =====
    const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
    const tf = (n, d=2) => (Number.isFinite(n) ? n.toFixed(d) : '—');
    const nfInt = new Intl.NumberFormat('en-US', {maximumFractionDigits: 0});
    const fmtInt = (n) => Number.isFinite(n) ? nfInt.format(Math.trunc(n)) : '—';

    // Costs & math
    const costAddDie = (k) => Math.round(25 * Math.pow(1.55, Math.max(0, k-1)));
    const costAddSideFor = (sides) => Math.round(12 + Math.pow(sides + 1, 1.45));
    const costAddWinningFaceFor = (w) => Math.round(18 * Math.pow(1.45, Math.max(0, w - 1)));
    const costAutoRoller = (level) => Math.round(80 * Math.pow(1.5, Math.max(0, level)));
    const costAutoBanker = () => 90;

    const autoIntervalMs = (level) => level<=0 ? null : Math.max(10, Math.round(2000 * Math.pow(0.75, level-1)));

    const computeStartingHeat = (dice) => 1 + 0.1 * dice.reduce((a,d)=>a + Math.max(0, d.sides-2), 0);
    const payoutFromDiceCount = (nDice) => 1 + 0.1 * Math.max(0, nDice-1);

    const OVERHEAT_STAGES = [
      { threshold: 2.5, addRisk: 0.05, label: 'Warm' },
      { threshold: 3.5, addRisk: 0.08, label: 'Hot' },
      { threshold: 4.5, addRisk: 0.12, label: 'Critical' },
    ];

    function computeOverheat(heatRaw){
      let accumulatedRisk = 0;
      let stageIndex = -1;
      let nextThreshold = null;
      for(let i=0;i<OVERHEAT_STAGES.length;i++){
        const stage = OVERHEAT_STAGES[i];
        if(heatRaw >= stage.threshold){
          accumulatedRisk = Math.min(0.95, accumulatedRisk + stage.addRisk);
          stageIndex = i;
        } else {
          nextThreshold = stage.threshold;
          break;
        }
      }
      const lastStage = OVERHEAT_STAGES[OVERHEAT_STAGES.length-1];
      if(stageIndex === OVERHEAT_STAGES.length-1){
        const extraHeat = Math.max(0, heatRaw - lastStage.threshold);
        const extraSteps = Math.floor(extraHeat);
        if(extraSteps>0){
          const extraRisk = Math.min(0.95 - accumulatedRisk, extraSteps * lastStage.addRisk);
          if(extraRisk>0){ accumulatedRisk = Math.min(0.95, accumulatedRisk + extraRisk); }
          stageIndex += extraSteps;
        }
        nextThreshold = lastStage.threshold + extraSteps + 1;
      }
      const stageLabel = (stageIndex>=0)
        ? (stageIndex < OVERHEAT_STAGES.length
            ? OVERHEAT_STAGES[stageIndex].label
            : `${OVERHEAT_STAGES[OVERHEAT_STAGES.length-1].label}+${stageIndex-OVERHEAT_STAGES.length+1}`)
        : null;
      return {risk: accumulatedRisk, stageIndex, stageLabel, nextThreshold};
    }
    const allowDestroy = (nDice) => nDice > 1;

    // SVG icon (coin for n<=2, n-gon otherwise)
    function diceIconSVG(n, label, selected, lastWin){
      const s=56, cx=s/2, cy=s/2, r=s*0.38;
      const stroke = selected ? '#34d399' : (lastWin ? '#10b981' : '#94a3b8');
      const sw = selected ? 3 : 2;
      const rect = `<rect x="0" y="0" width="${s}" height="${s}" rx="12" ry="12" fill="none" stroke="rgba(255,255,255,.08)"/>`;
      const shape = (n<=2)
        ? `<circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="${stroke}" stroke-width="${sw}"/>`
        : `<polygon points="${(function(){const rot=-Math.PI/2;const pts=[];for(let i=0;i<n;i++){const a=rot+(i*2*Math.PI)/n;pts.push(`${cx + r*Math.cos(a)},${cy + r*Math.sin(a)}`)}return pts.join(' ')}())}" fill="none" stroke="${stroke}" stroke-width="${sw}"/>`;
      const lab = label!=null ? `<text x="50%" y="52%" text-anchor="middle" dominant-baseline="middle" font-size="${s*0.42}" font-family="ui-sans-serif, system-ui" fill="currentColor">${label}</text>` : '';
      return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">${rect}${shape}${lab}</svg>`;
    }

    // ===== State =====
    const state = {
      bank: 0,
      pot: 0,
      streak: 0,
      hazardTokens: [],
      log: ["Ready. Press R to roll, B to bank."],
      hazardHelper: { nextId: 1 },
      dice: [{ id:1, sides:2, winningFaces:1 }],
      selectedDieId: 1,
      lastRoll: [], // {id,value,win}
      autoRollerLevel: 0,
      autoRollerActive: false,
      autoBankerOwned: false,
      autoBankerActive: false,
      autoBankerTarget: 20,
      addDieInflation: 1,
      globalPriceScale: 1,
      destroyedSides: 0,
      armedDestroyId: null,
    };

    // Timers
    let autoTimer = null; // interval id
    let autoResumeTimer = null; // timeout id for pause/resume
    let autoPausedUntil = 0; // timestamp in ms
    let interestTimer = null; // 1s compounding

    // ===== Derived =====
    function derived(){
      const payoutPerSuccess = payoutFromDiceCount(state.dice.length);
      const startingHeat = computeStartingHeat(state.dice);
      const heatRaw = startingHeat + 0.05 * state.streak;
      const heatPay = Math.floor(heatRaw);
      const overheat = computeOverheat(heatRaw);
      const baseBustProb = state.dice.reduce((acc,d)=>acc * (1 - d.winningFaces/d.sides), 1);
      const hazardBust = Math.min(0.95, state.hazardTokens.reduce((acc,t)=>acc + (t.bustBonus||0), 0));
      const bustProb = Math.min(0.999, baseBustProb + hazardBust);
      const expectedSuccesses = state.dice.reduce((acc,d)=>acc + d.winningFaces/d.sides, 0);

      const priceDie = Math.max(1, Math.round(costAddDie(state.dice.length) * state.addDieInflation * state.globalPriceScale));
      const selected = state.dice.find(d=>d.id===state.selectedDieId) || state.dice[0];
      const canAddSide = !!selected && selected.sides < 20;
      const canAddWinningFace = !!selected && selected.winningFaces < selected.sides - 1;
      const priceSide = selected ? Math.max(1, Math.round(costAddSideFor(selected.sides) * state.globalPriceScale)) : 0;
      const priceWin = selected ? Math.max(1, Math.round(costAddWinningFaceFor(selected.winningFaces) * state.globalPriceScale)) : 0;
      const priceAR = Math.max(1, Math.round(costAutoRoller(state.autoRollerLevel) * state.globalPriceScale));
      const priceAB = !state.autoBankerOwned ? Math.max(1, Math.round(costAutoBanker() * state.globalPriceScale)) : 0;
      const arMs = autoIntervalMs(state.autoRollerLevel);
      return {
        payoutPerSuccess,
        startingHeat,
        heatRaw,
        heatPay,
        overheat,
        bustProb,
        expectedSuccesses,
        priceDie,
        selected,
        canAddSide,
        canAddWinningFace,
        priceSide,
        priceWin,
        priceAR,
        priceAB,
        arMs
      };
    }

    // ===== Render =====
    function render(){
      const d = derived();
      // Top panels
      document.getElementById('bank').textContent = fmtInt(state.bank);
      document.getElementById('interestRate').textContent = (state.destroyedSides*0.1).toFixed(1);
      document.getElementById('priceScale').textContent = (state.globalPriceScale).toFixed(2);

      document.getElementById('pot').textContent = fmtInt(state.pot);
      document.getElementById('heatRaw').textContent = tf(d.heatRaw,2);
      document.getElementById('heatPay').textContent = Math.max(1, d.heatPay);
      document.getElementById('streak').textContent = state.streak;
      const overheatRiskEl = document.getElementById('overheatRisk');
      if(overheatRiskEl){ overheatRiskEl.textContent = tf(d.overheat.risk*100,1); }
      const ohStage = document.getElementById('overheatStage');
      if(ohStage){
        if(d.overheat.stageLabel){
          ohStage.textContent = d.overheat.stageLabel;
          ohStage.style.display = 'inline';
        } else {
          ohStage.style.display = 'none';
        }
      }
      const ohNext = document.getElementById('overheatNext');
      const ohNextValue = document.getElementById('overheatNextValue');
      if(ohNext && ohNextValue){
        if(d.overheat.nextThreshold){
          ohNextValue.textContent = tf(d.overheat.nextThreshold,1);
          ohNext.style.display = 'inline';
        } else {
          ohNext.style.display = 'none';
        }
      }

      const hazardBadge = document.getElementById('hazardBadge');
      if(hazardBadge){
        if(state.hazardTokens.length){
          hazardBadge.style.display = 'inline-block';
          hazardBadge.textContent = `${state.hazardTokens.length} hazard${state.hazardTokens.length>1?'s':''}`;
          hazardBadge.setAttribute('title', hazardSummary());
        } else {
          hazardBadge.style.display = 'none';
          hazardBadge.textContent = '';
          hazardBadge.removeAttribute('title');
        }
      }

      document.getElementById('diceCount').textContent = state.dice.length;
      document.getElementById('selectedStats').textContent = `#${d.selected?.id ?? '?'} — d${d.selected?.sides ?? '?'} , ${d.selected?.winningFaces ?? '?'} winning`;
      document.getElementById('baseHeat').textContent = tf(d.startingHeat,2);
      document.getElementById('perWin').textContent = tf(d.payoutPerSuccess,2);
      document.getElementById('bustPct').textContent = tf(d.bustProb*100,2);
      document.getElementById('expSucc').textContent = tf(d.expectedSuccesses,2);

      // Buttons panel (costs)
      document.getElementById('diceCountNow').textContent = state.dice.length;
      document.getElementById('diceCountNext').textContent = state.dice.length+1;
      document.getElementById('costDie').textContent = fmtInt(d.priceDie);

      document.getElementById('selSides').textContent = d.selected?.sides ?? 0;
      document.getElementById('selSidesNext').textContent = (d.selected ? d.selected.sides+1 : 0);
      document.getElementById('costSide').textContent = fmtInt(d.priceSide);

      document.getElementById('selWin').textContent = d.selected?.winningFaces ?? 0;
      document.getElementById('selSides2').textContent = d.selected?.sides ?? 0;
      document.getElementById('selWinNext').textContent = d.selected ? Math.min(d.selected.winningFaces+1, d.selected.sides-1) : 0;
      document.getElementById('selSides3').textContent = d.selected?.sides ?? 0;
      document.getElementById('costWin').textContent = fmtInt(d.priceWin);

      document.getElementById('arOwned').textContent = state.autoRollerLevel>0? 'Yes':'No';
      document.getElementById('arLevel').textContent = Math.max(0, state.autoRollerLevel);
      document.getElementById('arInterval').textContent = d.arMs ? `${fmtInt(d.arMs)} ms` : '—';
      document.getElementById('costAR').textContent = fmtInt(d.priceAR);

      document.getElementById('abOwned').textContent = state.autoBankerOwned? 'Yes':'No';
      const abTargetEl = document.getElementById('abTarget');
      abTargetEl.value = state.autoBankerTarget;
      abTargetEl.classList.toggle('pending', !state.autoBankerOwned);
      const abPendingHint = document.getElementById('abPendingHint');
      if(abPendingHint){ abPendingHint.style.display = state.autoBankerOwned ? 'none' : 'block'; }
      document.getElementById('costAB').textContent = fmtInt(d.priceAB);
      document.getElementById('btnToggleAB').textContent = state.autoBankerActive? 'Disable':'Enable';
      document.getElementById('btnToggleAR').textContent = state.autoRollerActive? 'Stop':'Start';

      // Enable/disable affordability
      document.getElementById('btnBuyDie').disabled = state.bank < d.priceDie;
      document.getElementById('btnBuySide').disabled = (!d.canAddSide) || state.bank < d.priceSide;
      document.getElementById('btnBuyWin').disabled = (!d.canAddWinningFace) || state.bank < d.priceWin;
      document.getElementById('btnBuyAR').disabled = state.bank < d.priceAR;
      document.getElementById('btnBuyAB').disabled = state.autoBankerOwned || state.bank < d.priceAB;
      document.getElementById('btnToggleAR').disabled = state.autoRollerLevel<=0;

      // Dice list
      const lastById = new Map();
      state.lastRoll.forEach(r=>lastById.set(r.id,{value:r.value,win:r.win}));
      const canDestroy = allowDestroy(state.dice.length);
      const tiles = state.dice.map(d=>{
        const lr = lastById.get(d.id);
        const val = lr ? lr.value : '?';
        const win = lr ? lr.win : false;
        const selected = state.selectedDieId===d.id;
        const arm = state.armedDestroyId===d.id;
        const destroyClass = !canDestroy ? 'destroy disabled' : (arm ? 'destroy active' : 'destroy');
        const destroyLabel = !canDestroy ? 'Destroy' : (arm ? 'Confirm' : 'Destroy');
        return `<div class="die-tile ${selected?'selected':''}" data-die="${d.id}">
            ${diceIconSVG(d.sides, val, selected, win)}
            <div>
              <div style="font-size:14px;font-weight:600">Die #${d.id} — d${d.sides}</div>
              <div style="font-size:12px;color:var(--muted2)">${d.winningFaces} winning face${d.winningFaces!==1?'s':''}</div>
              <div style="margin-top:6px">
                <span class="${destroyClass}" data-destroy="${d.id}">${destroyLabel}</span>
              </div>
            </div>
          </div>`;
      }).join('');
      const list = document.getElementById('diceList');
      list.innerHTML = tiles;

      // Log
      const logHtml = state.log.slice(0,20).map(s=>`<li>• ${s}</li>`).join('');
      document.getElementById('log').innerHTML = logHtml;
    }

    function addLog(s){ state.log.unshift(s); state.log = state.log.slice(0,50); }

    function hazardCounts(tokens=state.hazardTokens){
      return tokens.reduce((acc, token)=>{
        const key = token.kind || 'unknown';
        acc[key] = (acc[key] || 0) + 1;
        return acc;
      }, {});
    }

    function hazardLabel(kind){
      switch(kind){
        case 'ember': return 'Ember';
        case 'scorch': return 'Scorch';
        case 'spike': return 'Spike Trap';
        case 'overheat': return 'Overheat Residue';
        default: return 'Hazard';
      }
    }

    function hazardSummary(tokens=state.hazardTokens){
      const counts = hazardCounts(tokens);
      const parts = Object.entries(counts).map(([kind,count])=>`${count} ${hazardLabel(kind)}${count>1?'s':''}`);
      return parts.length ? parts.join(', ') : 'none';
    }

    function clearHazards(reason, options={}){
      if(state.hazardTokens.length===0) return;
      const { preserveKinds=[] } = options;
      const toRemove = preserveKinds.length
        ? state.hazardTokens.filter(token=>!preserveKinds.includes(token.kind))
        : state.hazardTokens.slice();
      if(toRemove.length===0) return;
      const summary = hazardSummary(toRemove);
      state.hazardTokens = preserveKinds.length
        ? state.hazardTokens.filter(token=>preserveKinds.includes(token.kind))
        : [];
      addLog(`${reason} Cleared hazards (${summary}).`);
    }

    function resolveHazardToken(token){
      if(token.kind==='ember'){
        token.bustBonus = (token.bustBonus||0) + 0.02;
        addLog('An ember hazard flickers. Bust odds +2%.');
      } else if(token.kind==='scorch'){
        const viable = state.dice.filter(d=>d.winningFaces>1);
        if(viable.length){
          const target = viable[Math.floor(Math.random()*viable.length)];
          state.dice = state.dice.map(d=> d.id===target.id ? {...d, winningFaces: Math.max(1, d.winningFaces-1)} : d);
          const updated = state.dice.find(d=>d.id===target.id);
          addLog(`Hazard scorched die #${target.id}. Winning faces now ${updated.winningFaces}/${updated.sides}.`);
        } else {
          token.bustBonus = (token.bustBonus||0) + 0.05;
          addLog('Hazard scorched the air, raising bust odds by 5%.');
        }
      } else if(token.kind==='spike'){
        token.bustBonus = (token.bustBonus||0) + 0.1;
        token.trap = true;
        addLog('A spike trap is set! Bust odds increased by 10% until you bank.');
      } else if(token.kind==='overheat'){
        const risk = clamp(token.risk ?? 0, 0, 0.95);
        const bonus = clamp(risk, 0.02, 0.5);
        token.bustBonus = (token.bustBonus||0) + bonus;
        const label = token.label ? ` (${token.label})` : '';
        const heatText = token.heat ? ` at ×${tf(token.heat,2)}` : '';
        addLog(`Residual overheat hazard${label}${heatText}. Bust odds +${tf(bonus*100,1)}%.`);
      }
    }

    function addHazardToken(kind, payload={}){
      if(!state.hazardHelper){ state.hazardHelper = { nextId: 1 }; }
      const token = { id: state.hazardHelper.nextId++, kind, ...payload };
      state.hazardTokens.push(token);
      resolveHazardToken(token);
      return token;
    }

    function addOverheatHazards(overheatInfo, heatRaw){
      if(!overheatInfo || !Number.isFinite(overheatInfo.risk) || overheatInfo.risk<=0){ return 0; }
      const payload = {
        risk: overheatInfo.risk,
        heat: heatRaw,
        label: overheatInfo.stageLabel || null,
        stage: overheatInfo.stageIndex ?? null,
      };
      addHazardToken('overheat', payload);
      return 1;
    }

    function addHazardsForStreak(nextStreak){
      addHazardToken('ember');
      if(nextStreak>=3) addHazardToken('scorch');
      if(nextStreak>=6) addHazardToken('spike');
    }

    // ===== Actions =====
    function roll(fromAuto=false){
      let successes = 0; const res = [];
      for(const d of state.dice){
        const v = 1 + Math.floor(Math.random()*d.sides);
        const win = v <= d.winningFaces; if(win) successes++;
        res.push({id:d.id,value:v,win});
      }
      state.lastRoll = res;
      if(successes===0){
        if(state.pot>0) addLog(`Bust. Lost pot of ${fmtInt(state.pot)}.`);
        state.pot = 0; state.streak = 0; clearHazards('Bust ended the run.'); render(); return;
      }
      const nextStreak = state.streak + 1;
      addHazardsForStreak(nextStreak);
      const d = derived();
      const payMult = Math.max(1, d.heatPay);
      const gain = Math.round(successes * d.payoutPerSuccess * payMult);
      const newPot = state.pot + gain;
      const forcedBust = d.overheat.risk>0 && Math.random() < d.overheat.risk;
      if(forcedBust){
        const lost = newPot;
        state.pot = 0;
        state.streak = 0;
        const riskPct = tf(d.overheat.risk*100,1);
        const lossText = lost>0 ? ` Lost pot of ${fmtInt(lost)}.` : '';
        addLog(`Overheated! Forced cooldown at ×${tf(d.heatRaw,2)} (${riskPct}% risk).${lossText}${fromAuto?' [auto-roll]':''}`);
        clearHazards('Overheat forced a cooldown.', { preserveKinds: ['overheat'] });
        addOverheatHazards(d.overheat, d.heatRaw);
        render();
        return;
      }
      const hazardChance = Math.min(0.9, state.hazardTokens.reduce((acc,t)=>acc + (t.bustBonus||0), 0));
      if(hazardChance>0 && Math.random() < hazardChance){
        const lost = newPot;
        state.pot = 0;
        state.streak = 0;
        const lossText = lost>0 ? ` Lost pot of ${fmtInt(lost)}.` : '';
        addLog(`Hazard trap triggered!${lossText}${fromAuto?' [auto-roll]':''}`);
        clearHazards('Trap discharged.');
        render();
        return;
      }
      if(state.autoBankerOwned && state.autoBankerActive && newPot >= state.autoBankerTarget){
        state.bank += newPot; state.pot = 0; state.streak = 0;
        addLog(`Auto-banked ${fmtInt(newPot)} (target ${fmtInt(state.autoBankerTarget)}+).${fromAuto?' [auto-roll]':''}`);
        clearHazards('Auto banked safely.');
      } else {
        state.pot = newPot; state.streak += 1;
        addLog(`Success: ${successes}/${state.dice.length} wins. +${fmtInt(gain)} to pot.${fromAuto?' [auto-roll]':''}`);
      }
      render();
    }

    function bankNow(){ if(state.pot<=0){ addLog('Nothing to bank.'); render(); return; } state.bank += state.pot; addLog(`Banked ${fmtInt(state.pot)}.`); state.pot=0; state.streak=0; clearHazards('Banked safely.'); render(); }

    function resetGame(){
      state.bank=0; state.pot=0; state.streak=0; state.hazardTokens=[]; state.hazardHelper={nextId:1}; state.dice=[{id:1,sides:2,winningFaces:1}]; state.selectedDieId=1; state.lastRoll=[];
      state.autoRollerLevel=0; state.autoRollerActive=false; state.autoBankerOwned=false; state.autoBankerActive=false; state.autoBankerTarget=20;
      state.addDieInflation=1; state.globalPriceScale=1; state.destroyedSides=0; state.armedDestroyId=null; state.log=["Reset to one coin (d2) with one winning face per-die."];
      refreshAutoTimer(); render();
    }

    function bumpAddDiePrice(){ state.addDieInflation *= 1.18; }

    function buyDie(){ const {priceDie}=derived(); if(state.bank<priceDie){ addLog('Insufficient funds for die.'); render(); return; }
      state.bank -= priceDie; const nextId = (state.dice.reduce((m,d)=>Math.max(m,d.id),0)+1)||1; state.dice.push({id:nextId,sides:2,winningFaces:1}); addLog(`Bought +1 die for ${fmtInt(priceDie)}. New die is d2 with 1 winning face.`); render(); }

    function buySide(){ const d=derived(); if(!d.selected || !d.canAddSide){ return; } if(state.bank<d.priceSide){ addLog('Insufficient funds for side.'); render(); return; }
      state.bank -= d.priceSide; state.dice = state.dice.map(x=> x.id===d.selected.id ? {...x, sides:x.sides+1, winningFaces: Math.min(x.winningFaces, x.sides+1)} : x ); bumpAddDiePrice(); addLog(`Die #${d.selected.id}: +1 side for ${fmtInt(d.priceSide)}. Now d${d.selected.sides+1}.`); render(); }

    function buyWinningFace(){ const d=derived(); if(!d.selected || !d.canAddWinningFace){ return; } if(state.bank<d.priceWin){ addLog('Insufficient funds for winning face.'); render(); return; }
      state.bank -= d.priceWin; state.dice = state.dice.map(x=> x.id===d.selected.id ? {...x, winningFaces: Math.min(x.winningFaces+1, x.sides-1)} : x ); bumpAddDiePrice(); addLog(`Die #${d.selected.id}: +1 winning face for ${fmtInt(d.priceWin)}. Now ${Math.min(d.selected.winningFaces+1, d.selected.sides-1)}/${d.selected.sides} win.`); render(); }

    function buyOrUpgradeAR(){ const d=derived(); if(state.bank<d.priceAR){ addLog('Insufficient funds for Auto Roller.'); render(); return; }
      state.bank -= d.priceAR; state.autoRollerLevel = Math.max(1, state.autoRollerLevel+1); bumpAddDiePrice(); addLog(`${state.autoRollerLevel>1?'Upgraded':'Bought'} Auto Roller for ${fmtInt(d.priceAR)}.`); refreshAutoTimer(); render(); }

    function toggleAR(){ if(state.autoRollerLevel<=0){ addLog('Buy the Auto Roller first.'); render(); return; } state.autoRollerActive = !state.autoRollerActive; addLog(`Auto Roller ${state.autoRollerActive?'started':'stopped'}.`); refreshAutoTimer(); render(); }

    function buyAB(){
      const d=derived();
      if(state.autoBankerOwned) return;
      if(state.bank<d.priceAB){ addLog('Insufficient funds for Auto Banker.'); render(); return; }
      const target = clamp(state.autoBankerTarget, 1, 1_000_000);
      state.autoBankerTarget = target;
      state.bank -= d.priceAB;
      state.autoBankerOwned=true;
      bumpAddDiePrice();
      addLog(`Bought Auto Banker for ${fmtInt(d.priceAB)}. Target ${fmtInt(target)}.`);
      render();
    }

    function toggleAB(){ if(!state.autoBankerOwned){ addLog('Buy the Auto Banker first.'); render(); return; } state.autoBankerActive=!state.autoBankerActive; addLog(`Auto Banker ${state.autoBankerActive?'enabled':'disabled'}. Target ${fmtInt(state.autoBankerTarget)}.`); render(); }

    function destroyDie(id){ if(!allowDestroy(state.dice.length)){ addLog('Cannot destroy your last die.'); render(); return; } const die = state.dice.find(d=>d.id===id); if(!die){ return; }
      state.globalPriceScale = Math.max(0.0001, state.globalPriceScale * 0.5); state.destroyedSides += die.sides; state.dice = state.dice.filter(d=>d.id!==id); if(state.selectedDieId===id){ state.selectedDieId = state.dice.length ? state.dice[0].id : -1; } state.armedDestroyId = null; addLog(`Destroyed die #${id} (d${die.sides}). Prices halved; interest +${(die.sides*0.1).toFixed(1)}%/tick.`); render(); }

    // ===== Timers =====
    function refreshAutoTimer(){
      if(autoTimer){ clearInterval(autoTimer); autoTimer=null; }
      if(autoResumeTimer){ clearTimeout(autoResumeTimer); autoResumeTimer=null; }
      const ms = autoIntervalMs(state.autoRollerLevel);
      if(!state.autoRollerActive || !ms){ autoPausedUntil = 0; return; }
      const now = Date.now();
      if(now < autoPausedUntil){
        autoResumeTimer = setTimeout(()=>{ autoResumeTimer=null; refreshAutoTimer(); }, Math.max(0, autoPausedUntil-now));
        return;
      }
      autoPausedUntil = 0;
      autoTimer = setInterval(()=>roll(true), ms);
    }

    function pauseAutoTemporarily(duration=350){
      if(!state.autoRollerActive) return;
      const now = Date.now();
      autoPausedUntil = Math.max(autoPausedUntil, now + Math.max(0, duration));
      if(autoTimer){ clearInterval(autoTimer); autoTimer=null; }
      if(autoResumeTimer){ clearTimeout(autoResumeTimer); autoResumeTimer=null; }
      autoResumeTimer = setTimeout(()=>{ autoResumeTimer=null; refreshAutoTimer(); }, Math.max(0, autoPausedUntil - Date.now()));
    }
    function ensureInterestTimer(){ if(interestTimer) return; interestTimer = setInterval(()=>{ if(state.destroyedSides>0){ state.bank += state.bank * state.destroyedSides * 0.001; render(); } }, 1000); }

    // ===== Events =====
    document.getElementById('btnReset').addEventListener('click', resetGame);
    document.getElementById('btnRoll').addEventListener('click', ()=>roll(false));
    document.getElementById('btnBank').addEventListener('click', bankNow);

    document.getElementById('btnBuyDie').addEventListener('click', buyDie);
    document.getElementById('btnBuySide').addEventListener('click', buySide);
    document.getElementById('btnBuyWin').addEventListener('click', buyWinningFace);

    document.getElementById('btnBuyAR').addEventListener('click', buyOrUpgradeAR);
    document.getElementById('btnToggleAR').addEventListener('click', toggleAR);

    document.getElementById('btnBuyAB').addEventListener('click', buyAB);
    document.getElementById('btnToggleAB').addEventListener('click', toggleAB);
    document.getElementById('abTarget').addEventListener('input', (e)=>{
      const raw = parseInt(e.target.value||'0',10);
      const next = clamp(Number.isNaN(raw)?0:raw, 1, 1_000_000);
      state.autoBankerTarget = next;
      e.target.value = next;
      if(!state.autoBankerOwned) return;
      render();
    });

    // Delegation: dice list
    const diceListEl = document.getElementById('diceList');

    diceListEl.addEventListener('pointerdown', ()=>pauseAutoTemporarily(450));

    diceListEl.addEventListener('click', (e)=>{
      pauseAutoTemporarily(450);
      const destroyEl = e.target.closest('[data-destroy]');
      if(destroyEl){
        const id = parseInt(destroyEl.getAttribute('data-destroy'),10);
        if(state.armedDestroyId === id){ destroyDie(id); return; }
        if(!allowDestroy(state.dice.length)) return; // ignore
        state.armedDestroyId = id; addLog(`Click Destroy again to confirm die #${id}.`); render();
        setTimeout(()=>{ if(state.armedDestroyId === id){ state.armedDestroyId = null; render(); } }, 2000);
        return;
      }
      const tile = e.target.closest('[data-die]');
      if(tile){ state.selectedDieId = parseInt(tile.getAttribute('data-die'),10); render(); }
    });

    // Keys R/B
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase(); if(k==='r'){ e.preventDefault(); roll(); } else if(k==='b'){ e.preventDefault(); bankNow(); }
    });

    // Minimal self-tests
    (function tests(){ try{
      console.assert(costAddDie(1)===25,'costAddDie(1)=25');
      console.assert(costAddDie(3)===61,'costAddDie(3)=61');
      const heat = computeStartingHeat([{id:1,sides:3,winningFaces:1},{id:2,sides:5,winningFaces:1}]);
      console.assert(Math.abs(heat-1.4)<1e-9,'d3+d5 heat 1.4');
      console.assert(autoIntervalMs(3) < autoIntervalMs(1),'AR speeds up');
      const oh = computeOverheat(3.6);
      console.assert(oh.risk>0 && oh.stageLabel==='Hot','overheat stages escalate');
    }catch(_){} })();

    // Boot
    ensureInterestTimer();
    render();
  </script>
</body>
</html>
