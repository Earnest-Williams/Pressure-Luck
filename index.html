<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Push‑Your‑Luck — Faces & Dice (Plain JS)</title>
  <style>
    :root{
      --bg1:#0f172a;/* slate-900 */
      --bg2:#0b1220;/* slate-950 */
      --text:#e2e8f0;/* slate-100 */
      --muted:#cbd5e1;/* slate-300 */
      --muted2:rgba(255,255,255,.7);
      --border:rgba(255,255,255,.1);
      --highlight:#34d399;/* emerald-400 */
      --accent:#10b981;/* emerald-500 */
      --accent2:#f59e0b;/* amber-500 */
      --danger:#f43f5e;/* rose-500 */
      --shadow:0 10px 15px -3px rgba(0,0,0,.2),0 4px 6px -4px rgba(0,0,0,.2);
    }
    html,body{height:100%;}
    body{margin:0;color:var(--text);background:linear-gradient(to bottom,var(--bg1),var(--bg2));font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";}
    .container{max-width:1100px;margin:0 auto;padding:24px;}
    h1{font-size:22px;margin:0;font-weight:600;letter-spacing:.2px}
    .row{display:flex;gap:12px;flex-wrap:wrap;}
    .grid-3{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:16px}
    @media (max-width:900px){.grid-3{grid-template-columns:1fr}}
    .grid-2{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:16px}
    @media (max-width:900px){.grid-2{grid-template-columns:1fr}}
    .card{border:1px solid var(--border);background:rgba(255,255,255,.05);border-radius:16px;padding:16px;box-shadow:var(--shadow)}
    .card .title{color:var(--muted2);text-transform:uppercase;letter-spacing:.08em;font-size:12px;margin-bottom:8px}
    .btn{border:1px solid var(--border);border-radius:14px;padding:10px 14px;background:transparent;color:var(--text);cursor:pointer}
    .btn:hover{background:rgba(255,255,255,.06)}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn-primary{background:var(--accent);border-color:var(--accent);color:#0f172a;font-weight:600}
    .btn-primary:hover{filter:brightness(1.05)}
    .btn-warn{border-color:var(--danger);color:#ffe4e6}
    .kbd{border:1px solid var(--border);border-radius:6px;padding:2px 6px}
    .pill{display:inline-block;border:1px solid var(--border);border-radius:10px;padding:2px 8px;font-size:12px}
    .muted{color:var(--muted2)}
    .dice-list{display:flex;flex-wrap:wrap;gap:12px}
    .die-tile{display:flex;align-items:center;gap:12px;border:1px solid var(--border);border-radius:12px;padding:10px 12px 10px 10px}
    .die-tile.selected{border-color:var(--highlight);background:rgba(16,185,129,.12)}
    .destroy{display:inline-block;border:1px solid var(--border);border-radius:10px;padding:2px 8px;font-size:12px}
    .destroy.active{border-color:#fecdd3;background:rgba(244,63,94,.2);color:#fee2e2}
    .destroy.disabled{opacity:.4;pointer-events:none}
    svg{display:block}
    .log{list-style:none;margin:0;padding:0}
    .log li{font-size:14px;color:var(--muted2);margin:4px 0}
    input[type=number]{width:110px;border:1px solid var(--border);border-radius:8px;background:rgba(0,0,0,.35);color:var(--text);padding:6px}
  </style>
</head>
<body>
  <div class="container">
    <header class="row" style="justify-content:space-between;align-items:center;margin-bottom:16px">
      <h1>Push‑Your‑Luck — Per‑Die Upgrades + Automation</h1>
      <button id="btnReset" class="btn">Reset</button>
    </header>

    <section class="grid-3" style="margin-bottom:16px">
      <div class="card">
        <div class="title">Bank</div>
        <div id="bank" style="font-size:32px;font-weight:700">0</div>
        <div class="muted" style="font-size:12px;margin-top:6px">Interest <span id="interestRate">+0.0</span>%/tick • Price scale ×<span id="priceScale">1.00</span></div>
      </div>
      <div class="card">
        <div class="title">Pot (at risk)</div>
        <div id="pot" style="font-size:32px;font-weight:700">0</div>
        <div class="muted" style="font-size:12px;margin-top:6px">Heat ×<span id="heatRaw">1.00</span> • Payout ×<span id="heatPay">1</span> • Streak <span id="streak">0</span></div>
      </div>
      <div class="card">
        <div class="title">Current Setup</div>
        <div style="font-size:14px">
          <div style="margin-bottom:6px">Dice: <span id="diceCount" style="font-weight:600">1</span></div>
          <div class="grid-2" style="row-gap:6px">
            <div>Selected die</div><div style="text-align:right;font-weight:600" id="selectedStats">#1 — d2, 1 winning</div>
            <div>Base heat</div><div style="text-align:right;font-weight:600">×<span id="baseHeat">1.00</span></div>
            <div>Base per‑win</div><div style="text-align:right;font-weight:600">×<span id="perWin">1.00</span></div>
            <div>Bust chance (roll)</div><div style="text-align:right;font-weight:600"><span id="bustPct">0.00</span>%</div>
            <div>Expected successes</div><div style="text-align:right;font-weight:600"><span id="expSucc">0.00</span></div>
          </div>
          <div class="muted" style="font-size:12px;margin-top:8px">Press <span class="kbd">R</span> to Roll, <span class="kbd">B</span> to Bank</div>
        </div>
      </div>
    </section>

    <section class="row" style="margin-bottom:16px">
      <button id="btnRoll" class="btn btn-primary">Roll</button>
      <button id="btnBank" class="btn" style="background:var(--accent2);border-color:var(--accent2);color:#0f172a;font-weight:600">Bank</button>
    </section>

    <section class="card" style="margin-bottom:16px">
      <div class="title">Dice & Last Roll (click a die to select)</div>
      <div id="diceList" class="dice-list"></div>
    </section>

    <section class="grid-3" style="margin-bottom:16px">
      <div class="card">
        <div class="title">Add a Die</div>
        <div class="muted" style="font-size:14px;margin-bottom:8px">New die starts as d2 with 1 winning face.</div>
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div>
            <div style="font-size:20px;font-weight:600"><span id="diceCountNow">1</span> → <span id="diceCountNext">2</span></div>
            <div class="muted" style="font-size:14px">Cost: <span id="costDie">25</span></div>
          </div>
          <button id="btnBuyDie" class="btn">Buy</button>
        </div>
      </div>

      <div class="card">
        <div class="title">Add a Side (selected die)</div>
        <div class="muted" style="font-size:14px;margin-bottom:8px">Increase sides on the selected die.</div>
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div>
            <div style="font-size:20px;font-weight:600">d<span id="selSides">2</span> → d<span id="selSidesNext">3</span></div>
            <div class="muted" style="font-size:14px">Cost: <span id="costSide">15</span></div>
          </div>
          <button id="btnBuySide" class="btn">Buy</button>
        </div>
      </div>

      <div class="card">
        <div class="title">Add a Winning Face (selected die)</div>
        <div class="muted" style="font-size:14px;margin-bottom:8px">Max is N−1 for that die.</div>
        <div class="row" style="justify-content:space-between;align-items:flex-end">
          <div>
            <div style="font-size:20px;font-weight:600"><span id="selWin">1</span>/<span id="selSides2">2</span> → <span id="selWinNext">1</span>/<span id="selSides3">2</span></div>
            <div class="muted" style="font-size:14px">Cost: <span id="costWin">18</span></div>
          </div>
          <button id="btnBuyWin" class="btn">Buy</button>
        </div>
      </div>
    </section>

    <section class="grid-2" style="margin-bottom:16px">
      <div class="card">
        <div class="title">Auto Roller</div>
        <div class="muted" style="font-size:14px;margin-bottom:10px">Automatically rolls at intervals. Upgrade to reduce the interval. Speed scales indefinitely.</div>
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
          <div>
            <div style="font-size:14px">Owned: <span id="arOwned" style="font-weight:600">No</span></div>
            <div style="font-size:14px">Level: <span id="arLevel" style="font-weight:600">0</span></div>
            <div style="font-size:14px">Interval: <span id="arInterval" style="font-weight:600">—</span></div>
          </div>
          <div class="row">
            <button id="btnBuyAR" class="btn">Buy/Upgrade (<span id="costAR">80</span>)</button>
            <button id="btnToggleAR" class="btn">Start</button>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="title">Auto Banker</div>
        <div class="muted" style="font-size:14px;margin-bottom:10px">Automatically banks when the pot reaches the target value. Price is fixed; affected by price reductions.</div>
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
          <div>
            <div style="font-size:14px">Owned: <span id="abOwned" style="font-weight:600">No</span></div>
            <div style="font-size:14px">Target: <input id="abTarget" type="number" min="1" step="1" value="20" disabled></div>
          </div>
          <div class="row">
            <button id="btnBuyAB" class="btn">Buy (<span id="costAB">90</span>)</button>
            <button id="btnToggleAB" class="btn">Enable</button>
          </div>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="title">Log</div>
      <ul id="log" class="log"></ul>
    </section>

    <p class="muted" style="font-size:12px;margin-top:12px">
      Rules: If at least one die shows a winning face, you add to the pot and may roll again or bank; if none win, you bust and lose the pot.
        Add a Die starts at 25 and scales ×1.55 for each die already owned; any non‑die purchase increases future Add‑a‑Die price by +18% (multiplicative).
      Starting heat adds +0.1 per side above 2 on each die; streak adds +0.05 per success. Only whole‑number heat levels (×2, ×3, …) multiply payout.
      Base per‑win payout increases by +0.1 for each additional die. Destroying a die halves all current buy prices and adds +0.1%/tick interest per side of the destroyed die.
    </p>
  </div>

  <script>
    // ===== Helpers =====
    const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
    const tf = (n, d=2) => (Number.isFinite(n) ? n.toFixed(d) : '—');

    // Costs & math
    const costAddDie = (k) => Math.round(25 * Math.pow(1.55, Math.max(0, k-1)));
    const costAddSideFor = (sides) => Math.round(12 + Math.pow(sides + 1, 1.45));
    const costAddWinningFaceFor = (w) => Math.round(18 * Math.pow(1.45, Math.max(0, w - 1)));
    const costAutoRoller = (level) => Math.round(80 * Math.pow(1.5, Math.max(0, level)));
    const costAutoBanker = () => 90;

    const autoIntervalMs = (level) => level<=0 ? null : Math.max(10, Math.round(2000 * Math.pow(0.75, level-1)));

    const computeStartingHeat = (dice) => 1 + 0.1 * dice.reduce((a,d)=>a + Math.max(0, d.sides-2), 0);
    const payoutFromDiceCount = (nDice) => 1 + 0.1 * Math.max(0, nDice-1);
    const allowDestroy = (nDice) => nDice > 1;

    // SVG icon (coin for n<=2, n-gon otherwise)
    function diceIconSVG(n, label, selected, lastWin){
      const s=56, cx=s/2, cy=s/2, r=s*0.38;
      const stroke = selected ? '#34d399' : (lastWin ? '#10b981' : '#94a3b8');
      const sw = selected ? 3 : 2;
      const rect = `<rect x="0" y="0" width="${s}" height="${s}" rx="12" ry="12" fill="none" stroke="rgba(255,255,255,.08)"/>`;
      const shape = (n<=2)
        ? `<circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="${stroke}" stroke-width="${sw}"/>`
        : `<polygon points="${(function(){const rot=-Math.PI/2;const pts=[];for(let i=0;i<n;i++){const a=rot+(i*2*Math.PI)/n;pts.push(`${cx + r*Math.cos(a)},${cy + r*Math.sin(a)}`)}return pts.join(' ')}())}" fill="none" stroke="${stroke}" stroke-width="${sw}"/>`;
      const lab = label!=null ? `<text x="50%" y="52%" text-anchor="middle" dominant-baseline="middle" font-size="${s*0.42}" font-family="ui-sans-serif, system-ui" fill="currentColor">${label}</text>` : '';
      return `<svg width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">${rect}${shape}${lab}</svg>`;
    }

    // ===== State =====
    const state = {
      bank: 0,
      pot: 0,
      streak: 0,
      dice: [{ id:1, sides:2, winningFaces:1 }],
      selectedDieId: 1,
      lastRoll: [], // {id,value,win}
      log: ["Ready. Press R to roll, B to bank."],
      autoRollerLevel: 0,
      autoRollerActive: false,
      autoBankerOwned: false,
      autoBankerActive: false,
      autoBankerTarget: 20,
      addDieInflation: 1,
      globalPriceScale: 1,
      destroyedSides: 0,
      armedDestroyId: null,
    };

    // Timers
    let autoTimer = null; // interval id
    let interestTimer = null; // 1s compounding

    // ===== Derived =====
    function derived(){
      const payoutPerSuccess = payoutFromDiceCount(state.dice.length);
      const startingHeat = computeStartingHeat(state.dice);
      const heatRaw = startingHeat + 0.05 * state.streak;
      const heatPay = Math.floor(heatRaw);
      const bustProb = state.dice.reduce((acc,d)=>acc * (1 - d.winningFaces/d.sides), 1);
      const expectedSuccesses = state.dice.reduce((acc,d)=>acc + d.winningFaces/d.sides, 0);

      const priceDie = Math.max(1, Math.round(costAddDie(state.dice.length) * state.addDieInflation * state.globalPriceScale));
      const selected = state.dice.find(d=>d.id===state.selectedDieId) || state.dice[0];
      const canAddSide = !!selected && selected.sides < 20;
      const canAddWinningFace = !!selected && selected.winningFaces < selected.sides - 1;
      const priceSide = selected ? Math.max(1, Math.round(costAddSideFor(selected.sides) * state.globalPriceScale)) : 0;
      const priceWin = selected ? Math.max(1, Math.round(costAddWinningFaceFor(selected.winningFaces) * state.globalPriceScale)) : 0;
      const priceAR = Math.max(1, Math.round(costAutoRoller(state.autoRollerLevel) * state.globalPriceScale));
      const priceAB = !state.autoBankerOwned ? Math.max(1, Math.round(costAutoBanker() * state.globalPriceScale)) : 0;
      const arMs = autoIntervalMs(state.autoRollerLevel);
      return {payoutPerSuccess, startingHeat, heatRaw, heatPay, bustProb, expectedSuccesses, priceDie, selected, canAddSide, canAddWinningFace, priceSide, priceWin, priceAR, priceAB, arMs};
    }

    // ===== Render =====
    function render(){
      const d = derived();
      // Top panels
      document.getElementById('bank').textContent = Math.floor(state.bank);
      document.getElementById('interestRate').textContent = (state.destroyedSides*0.1).toFixed(1);
      document.getElementById('priceScale').textContent = (state.globalPriceScale).toFixed(2);

      document.getElementById('pot').textContent = state.pot;
      document.getElementById('heatRaw').textContent = tf(d.heatRaw,2);
      document.getElementById('heatPay').textContent = Math.max(1, d.heatPay);
      document.getElementById('streak').textContent = state.streak;

      document.getElementById('diceCount').textContent = state.dice.length;
      document.getElementById('selectedStats').textContent = `#${d.selected?.id ?? '?'} — d${d.selected?.sides ?? '?'} , ${d.selected?.winningFaces ?? '?'} winning`;
      document.getElementById('baseHeat').textContent = tf(d.startingHeat,2);
      document.getElementById('perWin').textContent = tf(d.payoutPerSuccess,2);
      document.getElementById('bustPct').textContent = tf(d.bustProb*100,2);
      document.getElementById('expSucc').textContent = tf(d.expectedSuccesses,2);

      // Buttons panel (costs)
      document.getElementById('diceCountNow').textContent = state.dice.length;
      document.getElementById('diceCountNext').textContent = state.dice.length+1;
      document.getElementById('costDie').textContent = d.priceDie;

      document.getElementById('selSides').textContent = d.selected?.sides ?? 0;
      document.getElementById('selSidesNext').textContent = (d.selected ? d.selected.sides+1 : 0);
      document.getElementById('costSide').textContent = d.priceSide;

      document.getElementById('selWin').textContent = d.selected?.winningFaces ?? 0;
      document.getElementById('selSides2').textContent = d.selected?.sides ?? 0;
      document.getElementById('selWinNext').textContent = d.selected ? Math.min(d.selected.winningFaces+1, d.selected.sides-1) : 0;
      document.getElementById('selSides3').textContent = d.selected?.sides ?? 0;
      document.getElementById('costWin').textContent = d.priceWin;

      document.getElementById('arOwned').textContent = state.autoRollerLevel>0? 'Yes':'No';
      document.getElementById('arLevel').textContent = Math.max(0, state.autoRollerLevel);
      document.getElementById('arInterval').textContent = d.arMs ? `${d.arMs} ms` : '—';
      document.getElementById('costAR').textContent = d.priceAR;

      document.getElementById('abOwned').textContent = state.autoBankerOwned? 'Yes':'No';
      const abTargetEl = document.getElementById('abTarget');
      abTargetEl.disabled = !state.autoBankerOwned;
      abTargetEl.value = state.autoBankerTarget;
      document.getElementById('costAB').textContent = d.priceAB;
      document.getElementById('btnToggleAB').textContent = state.autoBankerActive? 'Disable':'Enable';
      document.getElementById('btnToggleAR').textContent = state.autoRollerActive? 'Stop':'Start';

      // Enable/disable affordability
      document.getElementById('btnBuyDie').disabled = state.bank < d.priceDie;
      document.getElementById('btnBuySide').disabled = (!d.canAddSide) || state.bank < d.priceSide;
      document.getElementById('btnBuyWin').disabled = (!d.canAddWinningFace) || state.bank < d.priceWin;
      document.getElementById('btnBuyAR').disabled = state.bank < d.priceAR;
      document.getElementById('btnBuyAB').disabled = state.autoBankerOwned || state.bank < d.priceAB;
      document.getElementById('btnToggleAR').disabled = state.autoRollerLevel<=0;

      // Dice list
      const lastById = new Map();
      state.lastRoll.forEach(r=>lastById.set(r.id,{value:r.value,win:r.win}));
      const canDestroy = allowDestroy(state.dice.length);
      const tiles = state.dice.map(d=>{
        const lr = lastById.get(d.id);
        const val = lr ? lr.value : '?';
        const win = lr ? lr.win : false;
        const selected = state.selectedDieId===d.id;
        const arm = state.armedDestroyId===d.id;
        const destroyClass = !canDestroy ? 'destroy disabled' : (arm ? 'destroy active' : 'destroy');
        const destroyLabel = !canDestroy ? 'Destroy' : (arm ? 'Confirm' : 'Destroy');
        return `<div class="die-tile ${selected?'selected':''}" data-die="${d.id}">
            ${diceIconSVG(d.sides, val, selected, win)}
            <div>
              <div style="font-size:14px;font-weight:600">Die #${d.id} — d${d.sides}</div>
              <div style="font-size:12px;color:var(--muted2)">${d.winningFaces} winning face${d.winningFaces!==1?'s':''}</div>
              <div style="margin-top:6px">
                <span class="${destroyClass}" data-destroy="${d.id}">${destroyLabel}</span>
              </div>
            </div>
          </div>`;
      }).join('');
      const list = document.getElementById('diceList');
      list.innerHTML = tiles;

      // Log
      const logHtml = state.log.slice(0,20).map(s=>`<li>• ${s}</li>`).join('');
      document.getElementById('log').innerHTML = logHtml;
    }

    function addLog(s){ state.log.unshift(s); state.log = state.log.slice(0,50); }

    // ===== Actions =====
    function roll(fromAuto=false){
      let successes = 0; const res = [];
      for(const d of state.dice){
        const v = 1 + Math.floor(Math.random()*d.sides);
        const win = v <= d.winningFaces; if(win) successes++;
        res.push({id:d.id,value:v,win});
      }
      state.lastRoll = res;
      if(successes===0){
        if(state.pot>0) addLog(`Bust. Lost pot of ${state.pot}.`);
        state.pot = 0; state.streak = 0; render(); return;
      }
      const d = derived();
      const payMult = Math.max(1, d.heatPay);
      const gain = Math.round(successes * d.payoutPerSuccess * payMult);
      const newPot = state.pot + gain;
      if(state.autoBankerOwned && state.autoBankerActive && newPot >= state.autoBankerTarget){
        state.bank += newPot; state.pot = 0; state.streak = 0;
        addLog(`Auto-banked ${newPot} (target ${state.autoBankerTarget}+).${fromAuto?' [auto-roll]':''}`);
      } else {
        state.pot = newPot; state.streak += 1;
        addLog(`Success: ${successes}/${state.dice.length} wins. +${gain} to pot.${fromAuto?' [auto-roll]':''}`);
      }
      render();
    }

    function bankNow(){ if(state.pot<=0){ addLog('Nothing to bank.'); render(); return; } state.bank += state.pot; addLog(`Banked ${state.pot}.`); state.pot=0; state.streak=0; render(); }

    function resetGame(){
      state.bank=0; state.pot=0; state.streak=0; state.dice=[{id:1,sides:2,winningFaces:1}]; state.selectedDieId=1; state.lastRoll=[];
      state.autoRollerLevel=0; state.autoRollerActive=false; state.autoBankerOwned=false; state.autoBankerActive=false; state.autoBankerTarget=20;
      state.addDieInflation=1; state.globalPriceScale=1; state.destroyedSides=0; state.armedDestroyId=null; state.log=["Reset to one coin (d2) with one winning face per-die."];
      refreshAutoTimer(); render();
    }

    function bumpAddDiePrice(){ state.addDieInflation *= 1.18; }

    function buyDie(){ const {priceDie}=derived(); if(state.bank<priceDie){ addLog('Insufficient funds for die.'); render(); return; }
      state.bank -= priceDie; const nextId = (state.dice.reduce((m,d)=>Math.max(m,d.id),0)+1)||1; state.dice.push({id:nextId,sides:2,winningFaces:1}); addLog(`Bought +1 die for ${priceDie}. New die is d2 with 1 winning face.`); render(); }

    function buySide(){ const d=derived(); if(!d.selected || !d.canAddSide){ return; } if(state.bank<d.priceSide){ addLog('Insufficient funds for side.'); render(); return; }
      state.bank -= d.priceSide; state.dice = state.dice.map(x=> x.id===d.selected.id ? {...x, sides:x.sides+1, winningFaces: Math.min(x.winningFaces, x.sides+1)} : x ); bumpAddDiePrice(); addLog(`Die #${d.selected.id}: +1 side for ${d.priceSide}. Now d${d.selected.sides+1}.`); render(); }

    function buyWinningFace(){ const d=derived(); if(!d.selected || !d.canAddWinningFace){ return; } if(state.bank<d.priceWin){ addLog('Insufficient funds for winning face.'); render(); return; }
      state.bank -= d.priceWin; state.dice = state.dice.map(x=> x.id===d.selected.id ? {...x, winningFaces: Math.min(x.winningFaces+1, x.sides-1)} : x ); bumpAddDiePrice(); addLog(`Die #${d.selected.id}: +1 winning face for ${d.priceWin}. Now ${Math.min(d.selected.winningFaces+1, d.selected.sides-1)}/${d.selected.sides} win.`); render(); }

    function buyOrUpgradeAR(){ const d=derived(); if(state.bank<d.priceAR){ addLog('Insufficient funds for Auto Roller.'); render(); return; }
      state.bank -= d.priceAR; state.autoRollerLevel = Math.max(1, state.autoRollerLevel+1); bumpAddDiePrice(); addLog(`${state.autoRollerLevel>1?'Upgraded':'Bought'} Auto Roller for ${d.priceAR}.`); refreshAutoTimer(); render(); }

    function toggleAR(){ if(state.autoRollerLevel<=0){ addLog('Buy the Auto Roller first.'); render(); return; } state.autoRollerActive = !state.autoRollerActive; addLog(`Auto Roller ${state.autoRollerActive?'started':'stopped'}.`); refreshAutoTimer(); render(); }

    function buyAB(){ const d=derived(); if(state.autoBankerOwned) return; if(state.bank<d.priceAB){ addLog('Insufficient funds for Auto Banker.'); render(); return; } state.bank -= d.priceAB; state.autoBankerOwned=true; bumpAddDiePrice(); addLog(`Bought Auto Banker for ${d.priceAB}.`); render(); }

    function toggleAB(){ if(!state.autoBankerOwned){ addLog('Buy the Auto Banker first.'); render(); return; } state.autoBankerActive=!state.autoBankerActive; addLog(`Auto Banker ${state.autoBankerActive?'enabled':'disabled'}. Target ${state.autoBankerTarget}.`); render(); }

    function destroyDie(id){ if(!allowDestroy(state.dice.length)){ addLog('Cannot destroy your last die.'); render(); return; } const die = state.dice.find(d=>d.id===id); if(!die){ return; }
      state.globalPriceScale = Math.max(0.0001, state.globalPriceScale * 0.5); state.destroyedSides += die.sides; state.dice = state.dice.filter(d=>d.id!==id); if(state.selectedDieId===id){ state.selectedDieId = state.dice.length ? state.dice[0].id : -1; } state.armedDestroyId = null; addLog(`Destroyed die #${id} (d${die.sides}). Prices halved; interest +${(die.sides*0.1).toFixed(1)}%/tick.`); render(); }

    // ===== Timers =====
    function refreshAutoTimer(){ if(autoTimer){ clearInterval(autoTimer); autoTimer=null; } const ms = autoIntervalMs(state.autoRollerLevel); if(state.autoRollerActive && ms){ autoTimer = setInterval(()=>roll(true), ms); } }
    function ensureInterestTimer(){ if(interestTimer) return; interestTimer = setInterval(()=>{ if(state.destroyedSides>0){ state.bank += state.bank * state.destroyedSides * 0.001; render(); } }, 1000); }

    // ===== Events =====
    document.getElementById('btnReset').addEventListener('click', resetGame);
    document.getElementById('btnRoll').addEventListener('click', ()=>roll(false));
    document.getElementById('btnBank').addEventListener('click', bankNow);

    document.getElementById('btnBuyDie').addEventListener('click', buyDie);
    document.getElementById('btnBuySide').addEventListener('click', buySide);
    document.getElementById('btnBuyWin').addEventListener('click', buyWinningFace);

    document.getElementById('btnBuyAR').addEventListener('click', buyOrUpgradeAR);
    document.getElementById('btnToggleAR').addEventListener('click', toggleAR);

    document.getElementById('btnBuyAB').addEventListener('click', buyAB);
    document.getElementById('btnToggleAB').addEventListener('click', toggleAB);
    document.getElementById('abTarget').addEventListener('input', (e)=>{ const v = parseInt(e.target.value||'0',10); state.autoBankerTarget = clamp(isNaN(v)?0:v, 1, 1_000_000); render(); });

    // Delegation: dice list
    document.getElementById('diceList').addEventListener('click', (e)=>{
      const destroyEl = e.target.closest('[data-destroy]');
      if(destroyEl){
        const id = parseInt(destroyEl.getAttribute('data-destroy'),10);
        if(state.armedDestroyId === id){ destroyDie(id); return; }
        if(!allowDestroy(state.dice.length)) return; // ignore
        state.armedDestroyId = id; addLog(`Click Destroy again to confirm die #${id}.`); render();
        setTimeout(()=>{ if(state.armedDestroyId === id){ state.armedDestroyId = null; render(); } }, 2000);
        return;
      }
      const tile = e.target.closest('[data-die]');
      if(tile){ state.selectedDieId = parseInt(tile.getAttribute('data-die'),10); render(); }
    });

    // Keys R/B
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase(); if(k==='r'){ e.preventDefault(); roll(); } else if(k==='b'){ e.preventDefault(); bankNow(); }
    });

    // Minimal self-tests
    (function tests(){ try{
      console.assert(costAddDie(1)===25,'costAddDie(1)=25');
      console.assert(costAddDie(3)===61,'costAddDie(3)=61');
      const heat = computeStartingHeat([{id:1,sides:3,winningFaces:1},{id:2,sides:5,winningFaces:1}]);
      console.assert(Math.abs(heat-1.4)<1e-9,'d3+d5 heat 1.4');
      console.assert(autoIntervalMs(3) < autoIntervalMs(1),'AR speeds up');
    }catch(_){} })();

    // Boot
    ensureInterestTimer();
    render();
  </script>
</body>
</html>
