<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Push Your Luck — Faces & Dice</title>
    <!-- Tailwind (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React 18 (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel Standalone for in-browser TSX/JSX transpile (dev only) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="min-h-screen bg-gradient-to-b from-slate-900 to-slate-950 text-slate-100">
    <div id="root"></div>

    <script type="text/babel" data-presets="typescript,react">
      // Pull hooks from global React (UMD)
      const { useMemo, useState, useEffect, useRef } = React;

      /** UI helpers **/
      const Card = ({ title, children, footer }) => (
        <div className="rounded-2xl shadow-lg p-4 bg-white/5 border border-white/10">
          <div className="text-sm uppercase tracking-wide text-white/70 mb-2">{title}</div>
          <div>{children}</div>
          {footer && <div className="mt-3 pt-3 border-t border-white/10 text-sm">{footer}</div>}
        </div>
      );

      const toFixed = (num, digits = 2) => (Number.isFinite(num) ? num.toFixed(digits) : "—");
      const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));

      // Wireframe coin/die icon
      const DiceIcon = ({ n, size = 56, selected = false, lastWin = false, label }) => {
        const s = size; const cx = s/2, cy = s/2; const r = s * 0.38;
        const stroke = selected ? "#34d399" : lastWin ? "#10b981" : "#94a3b8";
        const strokeWidth = selected ? 3 : 2;
        const makePoints = (k) => {
          const pts = []; const rot = -Math.PI/2;
          for (let i=0; i<k; i++) { const a = rot + (i * 2 * Math.PI) / k; const x = cx + r*Math.cos(a); const y = cy + r*Math.sin(a); pts.push(`${x},${y}`); }
          return pts.join(" ");
        };
        return (
          <svg width={s} height={s} viewBox={`0 0 ${s} ${s}`} className="shrink-0">
            <rect x={0} y={0} width={s} height={s} rx={12} ry={12} fill="none" stroke="rgba(255,255,255,0.08)" />
            {n <= 2 ? (
              <circle cx={cx} cy={cy} r={r} fill="none" stroke={stroke} strokeWidth={strokeWidth} />
            ) : (
              <polygon points={makePoints(n)} fill="none" stroke={stroke} strokeWidth={strokeWidth} />
            )}
            {label != null && (
              <text x="50%" y="52%" textAnchor="middle" dominantBaseline="middle" fontSize={s * 0.42}
                fontFamily="ui-sans-serif, system-ui" fill="currentColor">{String(label)}</text>
            )}
          </svg>
        );
      };

      /** Economics **/
      const costAddDie = (k) => 20 * Math.pow(2, Math.max(0, k - 1));
      const costAddSideFor = (sides) => Math.round(10 + 2 * sides);
      const costAddWinningFaceFor = (w) => Math.round(20 * Math.pow(1.3, w));
      const costAutoRoller = (level) => Math.round(50 * Math.pow(1.6, Math.max(0, level)));
      const costAutoBanker = () => 60;

      const intervalMsForAutoRoll = (level) => {
        if (level <= 0) return null;
        const base = 2000 * Math.pow(0.75, level - 1);
        return Math.max(10, Math.round(base));
      };

      const computeStartingHeat = (dice) => 1 + 0.1 * dice.reduce((acc, d) => acc + Math.max(0, d.sides - 2), 0);
      const payoutFromDiceCount = (nDice) => 1 + 0.1 * Math.max(0, nDice - 1);
      const allowDestroy = (nDice) => nDice > 1;

      /** Self-tests (console) **/
      (function runSelfTests(){
        try {
          console.assert(costAddDie(1) === 20, "costAddDie(1) should be 20");
          console.assert(costAddDie(2) === 40, "costAddDie(2) should be 40");
          console.assert(costAddDie(3) === 80, "costAddDie(3) should be 80");
          const d2 = [{ id:1, sides:2, winningFaces:1 }];
          const twoD3 = [{ id:1, sides:3, winningFaces:1 }, { id:2, sides:3, winningFaces:1 }];
          const d4 = [{ id:1, sides:4, winningFaces:1 }];
          console.assert(Math.abs(computeStartingHeat(d2) - 1.0) < 1e-9, "d2 base heat should be 1.0");
          console.assert(Math.abs(computeStartingHeat(twoD3) - 1.2) < 1e-9, "two d3 base heat should be 1.2");
          console.assert(Math.abs(computeStartingHeat(d4) - 1.2) < 1e-9, "d4 base heat should be 1.2");
          console.assert(Math.abs(payoutFromDiceCount(1) - 1.0) < 1e-9, "1 die per-win should be 1.0");
          console.assert(Math.abs(payoutFromDiceCount(3) - 1.2) < 1e-9, "3 dice per-win should be 1.2");
          console.assert(allowDestroy(1) === false, "cannot destroy when only 1 die");
          console.assert(allowDestroy(2) === true, "can destroy when 2+ dice");
          console.assert(costAddWinningFaceFor(0) === 20, "win cost base should be 20");
          console.assert(costAddWinningFaceFor(2) > costAddWinningFaceFor(1), "win cost should increase with w");
          const int1 = intervalMsForAutoRoll(1);
          const int3 = intervalMsForAutoRoll(3);
          console.assert(int3 < int1, "auto interval should shrink as level grows");
          console.assert(intervalMsForAutoRoll(100) >= 10, "auto interval should be clamped to >=10ms");
          const mix = [{ id:1, sides:3, winningFaces:1 }, { id:2, sides:5, winningFaces:1 }];
          console.assert(Math.abs(computeStartingHeat(mix) - 1.4) < 1e-9, "d3+d5 base heat should be 1.4");
          console.assert(costAddSideFor(2) < costAddSideFor(3), "side cost should increase with sides");
        } catch {}
      })();

      /** App **/
      function App(){
        const [bank, setBank] = useState(0);
        const [pot, setPot] = useState(0);
        const [streak, setStreak] = useState(0);

        const [dice, setDice] = useState([{ id:1, sides:2, winningFaces:1 }]);
        const [selectedDieId, setSelectedDieId] = useState(1);
        const [lastRoll, setLastRoll] = useState([]);
        const [log, setLog] = useState(["Ready. Press R to roll, B to bank."]);

        const payoutPerSuccess = useMemo(() => payoutFromDiceCount(dice.length), [dice.length]);
        const startingHeat = useMemo(() => computeStartingHeat(dice), [dice]);
        const heatRaw = startingHeat + 0.05 * streak;
        const heatPay = Math.floor(heatRaw);
        const bustProb = useMemo(() => dice.reduce((acc, d) => acc * (1 - d.winningFaces / d.sides), 1), [dice]);
        const expectedSuccesses = useMemo(() => dice.reduce((acc, d) => acc + d.winningFaces / d.sides, 0), [dice]);

        const [autoRollerLevel, setAutoRollerLevel] = useState(0);
        const [autoRollerActive, setAutoRollerActive] = useState(false);
        const autoRollIntervalMs = intervalMsForAutoRoll(autoRollerLevel);

        const [autoBankerOwned, setAutoBankerOwned] = useState(false);
        const [autoBankerActive, setAutoBankerActive] = useState(false);
        const [autoBankTarget, setAutoBankTarget] = useState(20);

        const [addDieInflation, setAddDieInflation] = useState(1);
        const [globalPriceScale, setGlobalPriceScale] = useState(1);
        const [destroyedSides, setDestroyedSides] = useState(0);

        const [armedDestroyId, setArmedDestroyId] = useState(null);
        const armTimer = useRef(null);
        useEffect(() => () => { if (armTimer.current) { clearTimeout(armTimer.current); armTimer.current = null; } }, []);

        useEffect(() => {
          const handler = (e) => {
            if (e.key.toLowerCase() === 'r') { e.preventDefault(); roll(); }
            else if (e.key.toLowerCase() === 'b') { e.preventDefault(); bankNow(); }
          };
          window.addEventListener('keydown', handler);
          return () => window.removeEventListener('keydown', handler);
        }, [dice, pot, streak, autoBankerActive, autoBankTarget, autoBankerOwned]);

        useEffect(() => {
          if (!autoRollerActive || !autoRollIntervalMs) return;
          const id = setInterval(() => roll(true), autoRollIntervalMs);
          return () => clearInterval(id);
        }, [autoRollerActive, autoRollIntervalMs, dice, pot, streak, autoBankerActive, autoBankTarget, autoBankerOwned]);

        useEffect(() => {
          if (destroyedSides <= 0) return;
          const id = setInterval(() => setBank(b => b + b * destroyedSides * 0.001), 1000);
          return () => clearInterval(id);
        }, [destroyedSides]);

        const appendLog = (s) => setLog(prev => [s, ...prev.slice(0, 7)]);

        function roll(fromAuto = false){
          let successes = 0; const results = [];
          for (const d of dice) {
            const v = 1 + Math.floor(Math.random() * d.sides);
            const win = v <= d.winningFaces; if (win) successes++;
            results.push({ value: v, win, id: d.id });
          }
          setLastRoll(results);
          if (successes === 0) { if (pot > 0) appendLog(`Bust. Lost pot of ${pot}.`); setPot(0); setStreak(0); return; }
          const payMult = Math.max(1, heatPay);
          const gain = Math.round(successes * payoutPerSuccess * payMult);
          const newPot = pot + gain;
          if (autoBankerOwned && autoBankerActive && newPot >= autoBankTarget) {
            setBank(b => b + newPot); setPot(0); setStreak(0);
            appendLog(`Auto-banked ${newPot} (target ${autoBankTarget}+).${fromAuto ? ' [auto-roll]' : ''}`);
          } else {
            setPot(newPot); setStreak(s => s + 1);
            appendLog(`Success: ${successes}/${dice.length} wins. +${gain} to pot.${fromAuto ? ' [auto-roll]' : ''}`);
          }
        }

        function bankNow(){ if (pot <= 0) { appendLog('Nothing to bank.'); return; } setBank(b => b + pot); appendLog(`Banked ${pot}.`); setPot(0); setStreak(0); }

        function resetGame(){
          setBank(0); setPot(0); setStreak(0);
          setDice([{ id:1, sides:2, winningFaces:1 }]);
          setSelectedDieId(1); setLastRoll([]);
          setAutoRollerLevel(0); setAutoRollerActive(false);
          setAutoBankerOwned(false); setAutoBankerActive(false); setAutoBankTarget(20);
          setAddDieInflation(1); setGlobalPriceScale(1); setDestroyedSides(0);
          setLog(['Reset to one coin (d2) with one winning face per-die.']);
        }

        const priceDie = Math.max(1, Math.round(costAddDie(dice.length) * addDieInflation * globalPriceScale));
        const selected = dice.find(d => d.id === selectedDieId) || dice[0];
        const canAddSide = selected ? selected.sides < 20 : false;
        const canAddWinningFace = selected ? selected.winningFaces < selected.sides - 1 : false;
        const priceSide = selected ? Math.max(1, Math.round(costAddSideFor(selected.sides) * globalPriceScale)) : 0;
        const priceWin = selected ? Math.max(1, Math.round(costAddWinningFaceFor(selected.winningFaces) * globalPriceScale)) : 0;
        const priceAutoRoll = Math.max(1, Math.round(costAutoRoller(autoRollerLevel) * globalPriceScale));
        const priceAutoBanker = !autoBankerOwned ? Math.max(1, Math.round(costAutoBanker() * globalPriceScale)) : 0;

        const bumpAddDiePrice = () => setAddDieInflation(x => x * 1.25);
        const buyDie = () => { if (bank < priceDie) { appendLog('Insufficient funds for die.'); return; } setBank(b => b - priceDie); setDice(ds => { const nextId = (ds.reduce((m,d)=>Math.max(m,d.id),0) + 1) || 1; return [...ds, { id: nextId, sides: 2, winningFaces: 1 }]; }); appendLog(`Bought +1 die for ${priceDie}. New die starts as d2 with 1 winning face.`); };
        const buySide = () => { if (!selected || !canAddSide) return; if (bank < priceSide) { appendLog('Insufficient funds for side.'); return; } setBank(b => b - priceSide); setDice(ds => ds.map(d => d.id === selected.id ? { ...d, sides: d.sides + 1, winningFaces: Math.min(d.winningFaces, d.sides) } : d)); bumpAddDiePrice(); appendLog(`Die #${selected.id}: added a side for ${priceSide}. Now d${selected.sides + 1}.`); };
        const buyWinningFace = () => { if (!selected || !canAddWinningFace) return; if (bank < priceWin) { appendLog('Insufficient funds for winning face.'); return; } setBank(b => b - priceWin); setDice(ds => ds.map(d => d.id === selected.id ? { ...d, winningFaces: Math.min(d.winningFaces + 1, d.sides - 1) } : d)); bumpAddDiePrice(); appendLog(`Die #${selected.id}: added a winning face for ${priceWin}. Now ${Math.min(selected.winningFaces + 1, selected.sides - 1)}/${selected.sides} win.`); };
        const buyOrUpgradeAutoRoller = () => { if (bank < priceAutoRoll) { appendLog('Insufficient funds for Auto Roller.'); return; } setBank(b => b - priceAutoRoll); setAutoRollerLevel(lv => Math.max(1, lv + 1)); bumpAddDiePrice(); appendLog(`${autoRollerLevel > 0 ? 'Upgraded' : 'Bought'} Auto Roller for ${priceAutoRoll}.`); };
        const toggleAutoRoller = () => { if (autoRollerLevel <= 0) { appendLog('Buy the Auto Roller first.'); return; } setAutoRollerActive(a => { const na = !a; appendLog(`Auto Roller ${na ? 'started' : 'stopped'}.`); return na; }); };
        const buyAutoBanker = () => { if (autoBankerOwned) return; if (bank < priceAutoBanker) { appendLog('Insufficient funds for Auto Banker.'); return; } setBank(b => b - priceAutoBanker); setAutoBankerOwned(true); bumpAddDiePrice(); appendLog(`Bought Auto Banker for ${priceAutoBanker}.`); };
        const toggleAutoBanker = () => { if (!autoBankerOwned) { appendLog('Buy the Auto Banker first.'); return; } setAutoBankerActive(a => { const na = !a; appendLog(`Auto Banker ${na ? 'enabled' : 'disabled'}. Target ${autoBankTarget}.`); return na; }); };
        const destroyDie = (id) => { setDice(ds => { if (!allowDestroy(ds.length)) { appendLog('Cannot destroy your last die.'); return ds; } const die = ds.find(d => d.id === id); if (!die) return ds; setGlobalPriceScale(s => Math.max(0.0001, s * 0.5)); setDestroyedSides(s => s + die.sides); const nd = ds.filter(d => d.id !== id); if (selectedDieId === id) setSelectedDieId(nd.length ? nd[0].id : -1); appendLog(`Destroyed die #${id} (d${die.sides}). Prices halved; interest +${(die.sides*0.1).toFixed(1)}%/tick.`); return nd; }); };

        return (
          <div className="min-h-screen w-full text-slate-100 p-6">
            <div className="max-w-6xl mx-auto space-y-6">
              <header className="flex items-center justify-between">
                <h1 className="text-2xl font-semibold tracking-tight">Push Your Luck — Per-Die Upgrades + Automation</h1>
                <div className="flex items-center gap-2">
                  <button onClick={resetGame} className="px-3 py-2 rounded-xl border border-white/10 hover:bg-white/5">Reset</button>
                </div>
              </header>

              <div className="grid md:grid-cols-3 gap-4">
                <Card title="Bank">
                  <div className="text-3xl font-bold">{Math.floor(bank)}</div>
                  <div className="text-xs mt-1 text-white/70">Interest +{toFixed(destroyedSides*0.1,2)}%/tick • Price scale ×{toFixed(globalPriceScale,2)}</div>
                </Card>
                <Card title="Pot (at risk)">
                  <div className="text-3xl font-bold">{pot}</div>
                  <div className="text-xs mt-1 text-white/70">Heat x{toFixed(heatRaw, 2)} • Payout x{Math.max(1, heatPay)} • Streak {streak}</div>
                </Card>
                <Card title="Current Setup" footer={<div className="text-white/70 text-xs">Press <kbd className="px-1.5 py-0.5 border rounded">R</kbd> to Roll, <kbd className="px-1.5 py-0.5 border rounded">B</kbd> to Bank</div>}>
                  <div className="text-sm text-white/80">
                    <div className="mb-2">Dice: <span className="font-semibold">{dice.length}</span></div>
                    <div className="grid grid-cols-2 gap-2 text-sm">
                      <div>Selected die</div>
                      <div className="text-right font-semibold">#{selected?.id} — d{selected?.sides}, {selected?.winningFaces} winning</div>
                      <div>Base heat</div>
                      <div className="text-right font-semibold">x{toFixed(startingHeat, 2)}</div>
                      <div>Base per-win</div>
                      <div className="text-right font-semibold">×{toFixed(payoutPerSuccess, 2)}</div>
                      <div>Bust chance (roll)</div>
                      <div className="text-right font-semibold">{toFixed(bustProb * 100, 2)}%</div>
                      <div>Expected successes</div>
                      <div className="text-right font-semibold">{toFixed(expectedSuccesses, 2)}</div>
                    </div>
                  </div>
                </Card>
              </div>

              <div className="flex gap-3">
                <button onClick={() => roll(false)} className="px-4 py-3 rounded-2xl bg-emerald-500/90 hover:bg-emerald-500 text-slate-900 font-semibold shadow">Roll</button>
                <button onClick={bankNow} className="px-4 py-3 rounded-2xl bg-amber-400/90 hover:bg-amber-400 text-slate-900 font-semibold shadow">Bank</button>
              </div>

              <Card title="Dice & Last Roll (click a die to select)">
                {(() => {
                  const canDestroy = allowDestroy(dice.length);
                  const lastById = new Map();
                  lastRoll.forEach(r => lastById.set(r.id, { value: r.value, win: r.win }));
                  return (
                    <div className="flex flex-wrap gap-3">
                      {dice.map(d => {
                        const lr = lastById.get(d.id);
                        const val = lr ? lr.value : undefined; const win = lr ? lr.win : false;
                        return (
                          <div key={d.id} role="button" tabIndex={0}
                            onClick={() => setSelectedDieId(d.id)}
                            onKeyDown={(e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); setSelectedDieId(d.id); }}}
                            className={`flex items-center gap-3 px-3 py-2 rounded-xl border text-left pr-4 ${selectedDieId===d.id?"border-emerald-400 bg-emerald-400/10":"border-white/10 hover:bg-white/5"}`}>
                            <DiceIcon n={d.sides} selected={selectedDieId===d.id} lastWin={win} label={val ?? "?"} />
                            <div>
                              <div className="text-sm font-semibold">Die #{d.id} — d{d.sides}</div>
                              <div className="text-xs text-white/80">{d.winningFaces} winning face{d.winningFaces!==1?"s":""}</div>
                              <div className="mt-1">
                                <span role="button" tabIndex={0}
                                  onClick={(e)=>{ if(!canDestroy) return; e.stopPropagation();
                                    if (armedDestroyId === d.id) {
                                      if (armTimer.current) { clearTimeout(armTimer.current); armTimer.current = null; }
                                      setArmedDestroyId(null);
                                      destroyDie(d.id);
                                    } else {
                                      setArmedDestroyId(d.id);
                                      appendLog(`Click Destroy again to confirm die #${d.id}.`);
                                      if (armTimer.current) clearTimeout(armTimer.current);
                                      armTimer.current = window.setTimeout(() => setArmedDestroyId(curr => (curr === d.id ? null : curr)), 2000);
                                    }
                                  }}
                                  aria-disabled={!canDestroy}
                                  title={canDestroy?(armedDestroyId===d.id?"Click again to confirm":"Destroy this die"):"You must keep at least one die"}
                                  className={`inline-block text-xs px-2 py-1 rounded-lg border ${canDestroy? (armedDestroyId===d.id?"border-rose-300 text-rose-100 bg-rose-500/20":"border-rose-400/60 text-rose-200 hover:bg-rose-400/10 cursor-pointer") : "opacity-40 border-white/10 text-white/40 cursor-not-allowed pointer-events-none"}`}>{armedDestroyId===d.id?"Confirm":"Destroy"}</span>
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  );
                })()}
              </Card>

              <div className="grid md:grid-cols-3 gap-4">
                <Card title="Add a Die">
                  <div className="text-sm text-white/80 mb-2">New die starts as d2 with 1 winning face.</div>
                  <div className="flex items-end justify-between">
                    <div>
                      <div className="text-xl font-semibold">{dice.length} → {dice.length + 1}</div>
                      <div className="text-white/70 text-sm">Cost: {priceDie}</div>
                    </div>
                    <button onClick={buyDie} disabled={bank < priceDie}
                      className={`px-3 py-2 rounded-xl border ${bank >= priceDie ? "border-emerald-400 hover:bg-emerald-400/10" : "border-white/10 opacity-50 cursor-not-allowed"}`}>
                      Buy
                    </button>
                  </div>
                </Card>

                <Card title="Add a Side (selected die)">
                  {selected ? (
                    <div>
                      <div className="text-sm text-white/80 mb-2">Increase sides on the selected die.</div>
                      <div className="flex items-end justify-between">
                        <div>
                          <div className="text-xl font-semibold">d{selected.sides} → d{selected.sides + 1}</div>
                          <div className="text-white/70 text-sm">Cost: {priceSide}</div>
                        </div>
                        <button onClick={buySide} disabled={!canAddSide || bank < priceSide}
                          className={`px-3 py-2 rounded-xl border ${bank >= priceSide && canAddSide ? "border-emerald-400 hover:bg-emerald-400/10" : "border-white/10 opacity-50 cursor-not-allowed"}`}>
                          Buy
                        </button>
                      </div>
                    </div>
                  ) : (
                    <div className="text-white/70">Select a die first.</div>
                  )}
                </Card>

                <Card title="Add a Winning Face (selected die)">
                  {selected ? (
                    <div>
                      <div className="text-sm text-white/80 mb-2">Max is N−1 for that die.</div>
                      <div className="flex items-end justify-between">
                        <div>
                          <div className="text-xl font-semibold">{selected.winningFaces}/{selected.sides} → {Math.min(selected.winningFaces + 1, selected.sides - 1)}/{selected.sides}</div>
                          <div className="text-white/70 text-sm">Cost: {priceWin}</div>
                        </div>
                        <button onClick={buyWinningFace} disabled={!canAddWinningFace || bank < priceWin}
                          className={`px-3 py-2 rounded-xl border ${bank >= priceWin && canAddWinningFace ? "border-emerald-400 hover:bg-emerald-400/10" : "border-white/10 opacity-50 cursor-not-allowed"}`}>
                          Buy
                        </button>
                      </div>
                    </div>
                  ) : (
                    <div className="text-white/70">Select a die first.</div>
                  )}
                </Card>
              </div>

              <div className="grid md:grid-cols-2 gap-4">
                <Card title="Auto Roller">
                  <div className="text-sm text-white/80 mb-3">Automatically rolls at intervals. Upgrade to reduce the interval. Speed scales indefinitely.</div>
                  <div className="flex items-center justify-between mb-3">
                    <div>
                      <div className="text-sm">Owned: <span className="font-semibold">{autoRollerLevel>0?"Yes":"No"}</span></div>
                      <div className="text-sm">Level: <span className="font-semibold">{Math.max(0, autoRollerLevel)}</span></div>
                      <div className="text-sm">Interval: <span className="font-semibold">{autoRollIntervalMs? `${autoRollIntervalMs} ms` : "—"}</span></div>
                    </div>
                    <div className="flex gap-2">
                      <button onClick={buyOrUpgradeAutoRoller} disabled={bank < priceAutoRoll}
                        className={`px-3 py-2 rounded-xl border ${bank >= priceAutoRoll ? "border-emerald-400 hover:bg-emerald-400/10" : "border-white/10 opacity-50 cursor-not-allowed"}`}>
                        {autoRollerLevel===0?"Buy":"Upgrade"} ({priceAutoRoll})
                      </button>
                      <button onClick={toggleAutoRoller} disabled={autoRollerLevel<=0}
                        className={`px-3 py-2 rounded-xl border ${autoRollerLevel>0 ? (autoRollerActive? "border-rose-300 hover:bg-rose-300/10" : "border-emerald-400 hover:bg-emerald-400/10") : "border-white/10 opacity-50 cursor-not-allowed"}`}>
                        {autoRollerActive?"Stop":"Start"}
                      </button>
                    </div>
                  </div>
                </Card>

                <Card title="Auto Banker">
                  <div className="text-sm text-white/80 mb-3">Automatically banks when the pot reaches the target value. Price is fixed; affected by price reductions.</div>
                  <div className="flex items-center justify-between mb-3">
                    <div className="space-y-1">
                      <div className="text-sm">Owned: <span className="font-semibold">{autoBankerOwned?"Yes":"No"}</span></div>
                      <div className="text-sm flex items-center gap-2">Target:
                        <input type="number" min={1} step={1} value={autoBankTarget}
                          onChange={(e)=> setAutoBankTarget(clamp(parseInt(e.target.value||"0",10) || 0, 1, 1_000_000))}
                          disabled={!autoBankerOwned}
                          className="w-28 px-2 py-1 rounded-lg bg-black/40 border border-white/10"/>
                      </div>
                    </div>
                    <div className="flex gap-2">
                      {!autoBankerOwned ? (
                        <button onClick={buyAutoBanker} disabled={bank < priceAutoBanker}
                          className={`px-3 py-2 rounded-xl border ${bank >= priceAutoBanker ? "border-emerald-400 hover:bg-emerald-400/10" : "border-white/10 opacity-50 cursor-not-allowed"}`}>
                          Buy ({priceAutoBanker})
                        </button>
                      ) : (
                        <button onClick={toggleAutoBanker}
                          className={`px-3 py-2 rounded-xl border ${autoBankerActive? "border-rose-300 hover:bg-rose-300/10" : "border-emerald-400 hover:bg-emerald-400/10"}`}>
                          {autoBankerActive?"Disable":"Enable"}
                        </button>
                      )}
                    </div>
                  </div>
                </Card>
              </div>

              <Card title="Log">
                <ul className="space-y-1 text-sm text-white/80">
                  {log.map((entry, idx) => (<li key={idx}>• {entry}</li>))}
                </ul>
              </Card>

              <div className="text-xs text-white/60">
                <p>
                  Rules: Roll your set of dice. If at least one die shows a winning face, you add to the pot and may roll again or bank. If none win, you bust and lose the pot.
                  You can add dice (first costs 20, each next doubles), and you can upgrade sides and winning faces per selected die (up to N−1 winning).
                  Starting heat adds +0.1 per side above 2 on each die; streak adds +0.05 per success. Only whole-number heat levels affect payout (×2, ×3, …).
                  Base per-win payout increases by +0.1 for each additional die. Auto Roller: buy/upgrade speed; Auto Banker: buy and set target. Destroying a die halves
                  all current buy prices and adds +0.1%/tick interest per side of the destroyed die. Inflation: buying anything other than Add a Die increases future Add a Die prices by +25%.
                </p>
              </div>
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>
